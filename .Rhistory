install.packages("devtools")
install.packages("forecast")
install.packages("rminer")
install.packages("R.matlab")
install.packages("scales")
install.packages("timeSeries")
install.packages("matrixStats")
install.packages("ggplot2")
install.packages("plyr")
install.packages("zoo")
install.packages("xts")
install.packages("dplyr")
install.packages("numDeriv")
install.packages("astsa")
install.packages("tsDyn")
install.packages("rgdal")
install.packages("hddtools")
install.packages("rts")
install.packages("GhcnDaily")
install.packages("bfast")
install.packages("downscaleR")
# HEIHE RIVER RUNOFF PREDICTION
# HEIHE RIVER RUNOFF PREDICTION
#
# tobias siegfried, 07. January 2016
# Version: 12 Jan. 2016
# INSTALL DOWNSCALING PACKAGE
install_github(c("SantanderMetGroup/downscaleR.java","SantanderMetGroup/downscaleR"))
install_github(c("SantanderMetGroup/loadeR.java","SantanderMetGroup/loadeR"))
# REQUIREMENTS ----
rm(list = ls()); cat("\014"); graphics.off(); # Clear Workspace
library(devtools)
library(forecast); library(rminer); library(R.matlab) ;
library(scales); library(timeSeries); library(matrixStats) # Load Packages
library(ggplot2); library(plyr); library(zoo); library(xts);
library(dplyr); library(numDeriv); library(astsa); library(tsDyn)
library(raster); library(rgdal);library(ggmap); library(hddtools)
library(RNetCDF)
library(rts)
library(GhcnDaily)
library(bfast)
library(downscaleR)
wdPath <- "/Users/tobiassiegfried/Dropbox (hydrosolutions)/iMoMoTOOLS/RRM_Heihe/R";
dataPath <- "/Users/tobiassiegfried/Dropbox (hydrosolutions)/iMoMoTOOLS/RRM_Heihe/data";
setwd(wdPath)
# FUNCTIONS ----
ensScatterPlot <- function(predD,obsD,h,pointS,plotTitle,xlabel,ylabel)
{
le.p <-  length(predD$pred[[1]]);
qZ.Da.pred.ens <- data.frame(matrix(nrow=le.p*nRuns,ncol = 2))
for(idx in 1:nRuns){
qZ.Da.pred.ens[((idx-1)*le.p+1):((idx-1)*le.p+le.p),1] <- (1:le.p) #rep((1:1332),each=nRuns)
qZ.Da.pred.ens[((idx-1)*le.p+1):((idx-1)*le.p+le.p),2] <- predD$pred[[idx]]
}
qZ.Da.pred.ens.summary <- qZ.Da.pred.ens %>% group_by(X1) %>%
summarize(ymin = min(X2),
ymax = max(X2),
ymean = mean(X2))
ggplot(qZ.Da.pred.ens.summary, aes(x = obsD$y[h$ts], y = ymean)) +
geom_point(size = pointS) +
geom_errorbar(aes(ymin = ymin, ymax = ymax)) +
ggtitle(plotTitle) +
xlab(xlabel) +
ylab(ylabel) +
coord_cartesian(xlim = c(-1,.5), ylim = c(-1,.5)) +
coord_fixed(ratio=1) +
geom_abline(intercept = 0 , slope = 1, col="red")
}
dwmTimeseries <- function(xData,y,m,d,aggFun)
{
tStart <- c(y,m,d)
tStartDate <- as.Date(paste(c(y,"-",m,"-",d),collapse=''))
qZ <- zooreg(xData, start = tStartDate)
qZ.Da <- qZ[format(time(qZ), "%m %d") != "02 29"] # remove leap days (makes leap days 'not' predicatble!)
qZ.Mo <- aggregate(qZ.Da,as.yearmon,aggFun) # monthly aggregation
qZ1 <- as.xts(qZ) # weekly aggregation
ep <- endpoints(qZ1, on = 'weeks')
qZ.We <- period.apply(x = qZ1, INDEX = ep, FUN = aggFun)
qZ.Da <- ts(as.vector(coredata(qZ.Da)), start = tStart,frequency = 365)
qZ.We <- ts(as.vector(coredata(qZ.We)), start = tStart,frequency = 52)
qZ.Mo <- ts(as.vector(coredata(qZ.Mo)), start = tStart,frequency = 12)
tsList <- list(qZ.Da,qZ.We,qZ.Mo)
return(tsList)
}
# DATA ACQUISITION ----
# DISCHARGE Q
qZ <- read.csv(file="~/Dropbox (hydrosolutions)/iMoMoTOOLS/RRM_Heihe/data/stream_flow_data/Zhamashike_runoff.csv", header=TRUE, sep=",")
qQ <- read.csv(file="~/Dropbox (hydrosolutions)/iMoMoTOOLS/RRM_Heihe/data/stream_flow_data/Qilian_runoff.csv", header=TRUE, sep=",")
qY <- read.csv(file="~/Dropbox (hydrosolutions)/iMoMoTOOLS/RRM_Heihe/data/stream_flow_data/Yingluoxia_runoff.csv", header=TRUE, sep=",")
qZ <- qZ[,-1]
qZ <- as.vector(as.matrix(qZ))
qZ <- na.omit(qZ)
qQ <- qQ[,-1]
qQ <- as.vector(as.matrix(qQ))
qQ <- na.omit(qQ)
qY <- qY[,-1]
qY <- as.vector(as.matrix(qY))
qY <- na.omit(qY)
# SNOW
sc.Q <- read.csv(file="/Users/tobiassiegfried/Dropbox (hydrosolutions)/iMoMoTOOLS/RRM_Heihe/R/JulesQilian.csv", header=TRUE, sep=",")
sc.Z <- read.csv(file="/Users/tobiassiegfried/Dropbox (hydrosolutions)/iMoMoTOOLS/RRM_Heihe/R/JulesZhamashike.csv", header=TRUE, sep=",")
plot(sc.Q)
plot(sc.Z)
# Correlation between catchments?
plot(sc.Q[,2],sc.Z[,2]); grid(); abline(0,1,col="red")
# WMO TEMPERATURE DATA
temp.Zhanye <- read.csv(file="/Users/tobiassiegfried/Dropbox (hydrosolutions)/iMoMoTOOLS/RRM_Heihe/R/526520.txt", header=TRUE, sep=",")
tTemp.start <- strptime(temp.Zhanye$YEARMODA[1], format = "%Y%m%d")
temp.Zhanye.ts <- dwmTimeseries(temp.Zhanye$TEMP,1960,03,25,"mean")
temp.Zhanye.ts.Da <- temp.Zhanye.ts[[1]]
temp.Zhanye.ts.We <- temp.Zhanye.ts[[2]]
temp.Zhanye.ts.Mo <- temp.Zhanye.ts[[3]]
plot(temp.Zhanye.ts.Mo); grid()
plot(decompose(temp.Zhanye.ts.Mo)$trend);grid()
# TREND DETECTION
decomp1 <- stl(temp.Zhanye.ts.Da,"periodic")
# CONSTRUCT TIME SERIES
qZts <- dwmTimeseries(qZ,2000,01,01,"mean"); qZ.Da <- qZts[[1]]; qZ.We <- qZts[[2]]; qZ.Mo <- qZts[[3]]
qQts <- dwmTimeseries(qQ,2000,01,01,"mean"); qQ.Da <- qQts[[1]]; qQ.We <- qQts[[2]]; qQ.Mo <- qQts[[3]]
qYts <- dwmTimeseries(qY,2000,01,01,"mean"); qY.Da <- qYts[[1]]; qY.We <- qYts[[2]]; qY.Mo <- qYts[[3]]
qS.Da <- qZ.Da + qQ.Da; qS.Mo <- qZ.Mo + qQ.Mo; qS.We <- qZ.We + qQ.We
# mean contribution to flow between upstream gauging stations and downstream Yingluosha
contrib.SY <- mean(qY.Da) - mean(qS.Da)
contrib.SY.perc <- contrib.SY / (mean(qS.Da)+contrib.SY)
contrib.Z.perc <- mean(qZ.Da) / (mean(qS.Da)+contrib.SY)
contrib.Q.perc <- mean(qQ.Da) / (mean(qS.Da)+contrib.SY)
contrib.Q.tot <- mean(qY.Da)
# REANALYSIS DATA ETC.
# TRMM Data
# GET TRMM DATA
# Downloaded from IRI
# Open nc with raster package directly
# Do loops to read and extract the data for each band!
precip.sum.Z.t <- vector(mode="numeric",length=4018)
precip.sum.Q.t <- vector(mode="numeric",length=4018)
precip.mean.Z.t <- vector(mode="numeric",length=4018)
precip.mean.Q.t <- vector(mode="numeric",length=4018)
for (t in 1:4018){
trmmNC <- raster("trmm3B42Heihe.nc",band=t)
precip.mean.Z.t[t] <- mean(extract(trmmNC,shape.Q)[[1]])
precip.mean.Q.t[t] <- mean(extract(trmmNC,shape.Z)[[1]])
}
# just for vis
trmmGrid <- matrix(0,nrow=40,ncol=40)
for (t in 1:4018){
trmmNC <- raster("trmm3B42Heihe.nc",band=t)
trmmGrid <- trmmGrid + getValues(trmmNC,format="matrix")
}
trmmGrid <- raster(trmmGrid)
plot(trmmGrid)
precip.mean.S.t <- (precip.mean.Q.t+precip.mean.Z.t)/2
precip.mean.Q <- dwmTimeseries(precip.mean.Q.t,2000,1,1,"sum") # sums over mean P in catchment cells
precip.mean.Z <- dwmTimeseries(precip.mean.Z.t,2000,1,1,"sum")
precip.mean.S <- dwmTimeseries(precip.mean.S.t,2000,1,1,"sum")
precip.mean.Q.Da <- precip.mean.Q[[1]]
precip.mean.Q.We <- precip.mean.Q[[2]]
precip.mean.Q.Mo <- precip.mean.Q[[3]]
precip.mean.Z.Da <- precip.mean.Z[[1]]
precip.mean.Z.We <- precip.mean.Z[[2]]
precip.mean.Z.Mo <- precip.mean.Z[[3]]
precip.mean.S.Da <- precip.mean.S[[1]]
precip.mean.S.We <- precip.mean.S[[2]]
precip.mean.S.Mo <- precip.mean.S[[3]]
plot(precip.mean.Z.Mo)
lines(precip.mean.Q.Mo,col="red")
grid()
# TOPOGRAPHY DATA
srtmTile <- getData('SRTM', lon=100, lat=38)
srtmTileW <- getData('SRTM', lon=98, lat=38)
srtmmosaic <- mosaic(srtmTile, srtmTileW, fun=mean)
breaks = quantile(srtmmosaic, seq(0, 1, length.out=256))
cols = colorRampPalette(c("#55FFFF", "grey10"))(255)
image(srtmmosaic, col=cols, breaks=breaks, axes=F, asp=T)
# Read shapefiles
shape.ZOld <- readOGR(dsn=".",layer="catchment_zhamashike")
shape.Z <- readOGR(dsn=".",layer="catchment_zhamashike_2")
shape.Q <- readOGR(dsn=".",layer="catchment_qilian")
shape.Z <- spTransform(shape.Z, CRS("+proj=longlat +datum=WGS84"))
shape.Q <- spTransform(shape.Q, CRS("+proj=longlat +datum=WGS84"))
image(srtmmosaic, col=cols, breaks=breaks, axes=F, asp=T)
lines(shape.Q,col="red")
lines(shape.Z,col="red")
map.Q <- intersect(srtmmosaic,shape.Q)
map.Z <- intersect(srtmmosaic,shape.Z)
lines(shape.Q,col="red")
lines(shape.Z,col="red")
plot(map.Z)
# LOOKING AT THINGS ----
plot(decompose(qS.Da)) # simple - use xts for more complex decomp
plot(decompose(qS.Mo))
plot(decompose(qS.We))
qS.Da.components <- decompose(qS.Da)
qZ.Da.components <- decompose(qZ.Da)
qQ.Da.components <- decompose(qQ.Da)
qS.Da.seasonallyAdjust <- qS.Da - qS.Da.components$seasonal
qS.Da.trendAdjust <- qS.Da - qS.Da.components$trend
plot(qS.Da.seasonallyAdjust)
plot(qS.Da.trendAdjust)
ts.plot(qS.Da,qY.Da,gpars=list(col=rainbow(3)[c(1,3)]),xlab="time",ylab="mean decadal runoff [m^3/s]")
ts.plot(qQ.Da,qZ.Da,gpars=list(col=rainbow(3)[c(1,3)]),xlab="time",ylab="mean decadal runoff [m^3/s]")
qS.Comp = stl(qS.Da, s.window="periodic")
plot(qS.Comp)
acf(qS.Da,lag.max=365)
acf(qS.We,lag.max=52)
acf(qS.Mo,lag.max=12)
# DATA PREPROCESSING ----
maxLag.Da <- 20;
maxLag.We <- 52;
maxLag.Mo <- 12;
#doy <- yday(time(as.zooreg(qZ.Da))
#wey <- week(time(qZ))
#moy <- month(time(qZ))
# Zhanmashike daily
qZ.Da.rs <- rescale(qZ.Da,to=c(-1,1))
qZ.Da.rs.lag <- CasesSeries(qZ.Da.rs,c(1:maxLag.Da))
qZ.Da.rs.lag <- na.omit(qZ.Da.rs.lag)
# Zhanmashike weekly
qZ.We.rs <- rescale(qZ.We,to=c(-1,1))
qZ.We.rs.lag <- CasesSeries(qZ.We.rs,c(1:maxLag.We))
qZ.We.rs.lag <- na.omit(qZ.We.rs.lag)
# Zhanmashike monthly
qZ.Mo.rs <- rescale(qZ.Mo,to=c(-1,1))
qZ.Mo.rs.lag <- CasesSeries(qZ.Mo.rs,c(1:maxLag.Mo))
qZ.Mo.rs.lag <- na.omit(qZ.Mo.rs.lag)
# Qilian daily
qQ.Da.rs <- rescale(qQ.Da,to=c(-1,1))
qQ.Da.rs.lag <- CasesSeries(qQ.Da.rs,c(1:maxLag.Da))
qQ.Da.rs.lag <- na.omit(qQ.Da.rs.lag)
# Qilian weekly
qQ.We.rs <- rescale(qQ.We,to=c(-1,1))
qQ.We.rs.lag <- CasesSeries(qQ.We.rs,c(1:maxLag.We))
qQ.We.rs.lag <- na.omit(qQ.We.rs.lag)
# Qilian monthly
qQ.Mo.rs <- rescale(qQ.Mo,to=c(-1,1))
qQ.Mo.rs.lag <- CasesSeries(qQ.Mo.rs,c(1:maxLag.Mo))
qQ.Mo.rs.lag <- na.omit(qQ.Mo.rs.lag)
# Zhanmashike plus Qilian daily
qS.Da.rs <- rescale(qS.Da,to=c(-1,1))
qS.Da.rs.lag <- CasesSeries(qS.Da.rs,c(1:maxLag.Da))
qS.Da.rs.lag <- na.omit(qS.Da.rs.lag)
# Zhanmashike plus Qilian weekly
qS.We.rs <- rescale(qS.We,to=c(-1,1))
qS.We.rs.lag <- CasesSeries(qS.We.rs,c(1:maxLag.We))
qS.We.rs.lag <- na.omit(qS.We.rs.lag)
# Zhanmashike plus Qilian monthly
qS.Mo.rs <- rescale(qS.Mo,to=c(-1,1))
qS.Mo.rs.lag <- CasesSeries(qS.Mo.rs,c(1:maxLag.Mo))
qS.Mo.rs.lag <- na.omit(qS.Mo.rs.lag)
# plot and compare specific runoff
area.Z <- 4.5892e+09;
area.Q <- 2.4586e+09;
area.total <- area.Q + area.Z #7000 km^2
plot((qZ.Da/area.Z),(qQ.Da/area.Q)); grid()
plot((qZ.Da/area.Z))
lines((qQ.Da/area.Q))
# lagged cross-correlations
ccf(na.omit(coredata(qZ.Da)),na.omit(coredata(qQ.Da)),365)
ccf(na.omit(qQ.Da.components$random),na.omit(qZ.Da.components$random),365) # highly corrleated noise points to joint events in extreme P
plot(qZ.Da.components$random)
lines(qQ.Da.components$random,col="red")
plot(diff(qS.Da))
# MINING ----
nRuns = 20;
# mlpe
qS.Da.mlpe <- mining(y~.,data=qS.Da.rs.lag,Runs=nRuns,method=c("holdoutorder",2/3,12345),model="mlpe",
search=list(search=mparheuristic("mlpe",n=5),method=c("kfoldorder",2,123),metric="MAE"),
feature="sabs")
qS.We.mlpe <- mining(y~.,data=qS.We.rs.lag,Runs=nRuns,method=c("holdoutorder",2/3,12345),model="mlpe",
search=list(search=mparheuristic("mlpe",n=5),method=c("kfoldorder",2,123),metric="MAE"),
feature="sabs")
qS.Mo.mlpe <- mining(y~.,data=qS.Mo.rs.lag,Runs=nRuns,method=c("holdoutorder",2/3,12345),model="mlpe",
search=list(search=mparheuristic("mlpe",n=5),method=c("kfoldorder",2,123),metric="MAE"),
feature="sabs")
# ksvm
qS.Da.ksvm <- mining(y~.,data=qS.Da.rs.lag,Runs=nRuns,method=c("holdoutorder",2/3,12345),model="ksvm",
search=list(search=mparheuristic("ksvm",n=5),method=c("kfoldorder",2,123),metric="MAE"),
feature="sabs")
qS.We.ksvm <- mining(y~.,data=qS.We.rs.lag,Runs=nRuns,method=c("holdoutorder",2/3,12345),model="ksvm",
search=list(search=mparheuristic("mlpe",n=5),method=c("kfoldorder",2,123),metric="MAE"),
feature="sabs")
qS.Mo.ksvm <- mining(y~.,data=qS.Mo.rs.lag,Runs=nRuns,method=c("holdoutorder",2/3,12345),model="ksvm",
search=list(search=mparheuristic("ksvm",n=5),method=c("kfoldorder",2,123),metric="MAE"),
feature="sabs")
# mars
qS.Da.mars <- mining(y~.,data=qS.Da.rs.lag,Runs=nRuns,method=c("holdoutorder",2/3,12345),model="mars",
search=list(search=mparheuristic("mars",n=5),method=c("kfoldorder",2,123),metric="MAE"))
qS.We.mars <- mining(y~.,data=qS.We.rs.lag,Runs=nRuns,method=c("holdoutorder",2/3,12345),model="mars",
search=list(search=mparheuristic("mars",n=5),method=c("kfoldorder",2,123),metric="MAE"))
qS.Mo.mars <- mining(y~.,data=qS.Mo.rs.lag,Runs=nRuns,method=c("holdoutorder",2/3,12345),model="mars",
search=list(search=mparheuristic("mars",n=5),method=c("kfoldorder",2,123),metric="MAE"))
# randomForest
qS.Da.randomForest <- mining(y~.,data=qS.Da.rs.lag,Runs=nRuns,method=c("holdoutorder",2/3,12345),model="randomForest",
search=list(search=mparheuristic("randomForest",n=5),method=c("kfoldorder",2,123),metric="MAE"))
qS.We.randomForest <- mining(y~.,data=qS.We.rs.lag,Runs=nRuns,method=c("holdoutorder",2/3,12345),model="randomForest",
search=list(search=mparheuristic("randomForest",n=5),method=c("kfoldorder",2,123),metric="MAE"))
qS.Mo.randomForest <- mining(y~.,data=qS.Mo.rs.lag,Runs=nRuns,method=c("holdoutorder",2/3,12345),model="randomForest",
search=list(search=mparheuristic("randomForest",n=5),method=c("kfoldorder",2,123),metric="MAE"))
# cubist
qS.Da.cubist <- mining(y~.,data=qS.Da.rs.lag,Runs=nRuns,method=c("holdoutorder",2/3,12345),model="cubist",
search=list(search=mparheuristic("cubist",n=5),method=c("kfoldorder",2,123),metric="MAE"))
qS.We.cubist <- mining(y~.,data=qS.We.rs.lag,Runs=nRuns,method=c("holdoutorder",2/3,12345),model="cubist",
search=list(search=mparheuristic("cubist",n=5),method=c("kfoldorder",2,123),metric="MAE"))
qS.Mo.cubist <- mining(y~.,data=qS.Mo.rs.lag,Runs=nRuns,method=c("holdoutorder",2/3,12345),model="cubist",
search=list(search=mparheuristic("cubist",n=5),method=c("kfoldorder",2,123),metric="MAE"))
# ID BEST MODEL ----
qS.Da.mlpe.err <- mmetric(qS.Da.mlpe,metric=c("MAE","RMSE"))
qS.We.mlpe.err <- mmetric(qS.We.mlpe,metric=c("MAE","RMSE"))
qS.Mo.mlpe.err <- mmetric(qS.Mo.mlpe,metric=c("MAE","RMSE"))
qS.Da.ksvm.err <- mmetric(qS.Da.ksvm,metric=c("MAE","RMSE"))
qS.We.ksvm.err <- mmetric(qS.We.ksvm,metric=c("MAE","RMSE"))
qS.Mo.ksvm.err <- mmetric(qS.Mo.ksvm,metric=c("MAE","RMSE"))
qS.Da.mars.err <- mmetric(qS.Da.mars,metric=c("MAE","RMSE"))
qS.We.mars.err <- mmetric(qS.We.mars,metric=c("MAE","RMSE"))
qS.Mo.mars.err <- mmetric(qS.Mo.mars,metric=c("MAE","RMSE"))
qS.Da.randomForest.err <- mmetric(qS.Da.randomForest,metric=c("MAE","RMSE"))
qS.We.randomForest.err <- mmetric(qS.We.randomForest,metric=c("MAE","RMSE"))
qS.Mo.randomForest.err <- mmetric(qS.Mo.randomForest,metric=c("MAE","RMSE"))
qS.Da.cubist.err <- mmetric(qS.Da.cubist,metric=c("MAE","RMSE"))
qS.We.cubist.err <- mmetric(qS.We.cubist,metric=c("MAE","RMSE"))
qS.Mo.cubist.err <- mmetric(qS.Mo.cubist,metric=c("MAE","RMSE"))
# Prining results
print("daily")
print(colMeans(qS.Da.mlpe.err))
print(colMeans(qS.Da.ksvm.err))
print(colMeans(qS.Da.mars.err))
print(colMeans(qS.Da.randomForest.err))
print(colMeans(qS.Da.cubist.err))
print("weekly")
print(colMeans(qS.We.mlpe.err))
print(colMeans(qS.We.ksvm.err))
print(colMeans(qS.We.mars.err))
print(colMeans(qS.We.randomForest.err))
print(colMeans(qS.We.cubist.err))
print("monthly")
print(colMeans(qS.Mo.mlpe.err))
print(colMeans(qS.Mo.ksvm.err))
print(colMeans(qS.Mo.mars.err))
print(colMeans(qS.Mo.randomForest.err))
print(colMeans(qS.Mo.cubist.err))
# Scatter/Whisker for the best model ----
# Daily
h.Da <- holdout(qS.Da.rs.lag$y, ratio = 2/3, mode = "order", seed = 12345) # just for ID later on!
ensScatterPlot(qS.Da.mlpe,qS.Da.rs.lag,h.Da,2,paste("mlpe: Zhamashike + Qilian Daily, MAE: ",toString(colMeans(qS.Da.mlpe.err)[[1]])),"observation","forecast")
ensScatterPlot(qS.Da.ksvm,qS.Da.rs.lag,h.Da,2,paste("ksvm: Zhamashike + Qilian Daily, MAE: ",toString(colMeans(qS.Da.ksvm.err)[[1]])),"observation","forecast")
ensScatterPlot(qS.Da.mars,qS.Da.rs.lag,h.Da,2,paste("mars: Zhamashike + Qilian Daily, MAE: ",toString(colMeans(qS.Da.mars.err)[[1]])),"observation","forecast")
ensScatterPlot(qS.Da.randomForest,qS.Da.rs.lag,h.Da,2,paste("rF: Zhamashike + Qilian Daily, MAE: ",toString(colMeans(qS.Da.randomForest.err)[[1]])),"observation","forecast")
ensScatterPlot(qS.Da.cubist,qS.Da.rs.lag,h.Da,2,paste("cubist: Zhamashike + Qilian Daily, MAE: ",toString(colMeans(qS.Da.cubist.err)[[1]])),"observation","forecast")
# WINNER: mlpe
# Weekly
h.We <- holdout(qS.We.rs.lag$y, ratio = 2/3, mode = "order", seed = 12345) # just for ID later on!
ensScatterPlot(qS.We.mlpe,qS.We.rs.lag,h.We,2,paste("mlpe: Zhamashike + Qilian Weekly, MAE: ",toString(colMeans(qS.We.mlpe.err)[[1]])),"observation","forecast")
ensScatterPlot(qS.We.ksvm,qS.We.rs.lag,h.We,2,paste("ksvm: Zhamashike + Qilian Weekly, MAE: ",toString(colMeans(qS.We.ksvm.err)[[1]])),"observation","forecast")
ensScatterPlot(qS.We.mars,qS.We.rs.lag,h.We,2,paste("mars: Zhamashike + Qilian Weekly, MAE: ",toString(colMeans(qS.We.mars.err)[[1]])),"observation","forecast")
ensScatterPlot(qS.We.randomForest,qS.We.rs.lag,h.We,2,paste("rF: Zhamashike + Qilian Weekly, MAE: ",toString(colMeans(qS.We.randomForest.err)[[1]])),"observation","forecast")
ensScatterPlot(qS.We.cubist,qS.We.rs.lag,h.We,2,paste("cubist: Zhamashike + Qilian Weekly, MAE: ",toString(colMeans(qS.We.cubist.err)[[1]])),"observation","forecast")
# WINNER: randomForest
# Monthly
h.Mo <- holdout(qS.Mo.rs.lag$y, ratio = 2/3, mode = "order", seed = 12345) # just for ID later on!
ensScatterPlot(qS.Mo.mlpe,qS.Mo.rs.lag,h.Mo,2,paste("mlpe: Zhamashike + Qilian Monthly, MAE: ",toString(colMeans(qS.Mo.mlpe.err)[[1]])),"observation","forecast")
ensScatterPlot(qS.Mo.ksvm,qS.Mo.rs.lag,h.Mo,2,paste("ksvm: Zhamashike + Qilian Monthly, MAE: ",toString(colMeans(qS.Mo.ksvm.err)[[1]])),"observation","forecast")
ensScatterPlot(qS.Mo.mars,qS.Mo.rs.lag,h.Mo,2,paste("mars: Zhamashike + Qilian Monthly, MAE: ",toString(colMeans(qS.Mo.mars.err)[[1]])),"observation","forecast")
ensScatterPlot(qS.Mo.randomForest,qS.Mo.rs.lag,h.Mo,2,paste("rF: Zhamashike + Qilian Monthly, MAE: ",toString(colMeans(qS.Mo.randomForest.err)[[1]])),"observation","forecast")
ensScatterPlot(qS.Mo.cubist,qS.Mo.rs.lag,h.Mo,2,paste("cubist: Zhamashike + Qilian Monthly, MAE: ",toString(colMeans(qS.Mo.cubist.err)[[1]])),"observation","forecast")
# WINNER: cubist
# PREDICTION
# SHINY STUFF
# GEOSPATIAL DATA ----
#map.Q.crop <- mask(srtmmosaic,shape.Q)
#map.Q.crop <- trim(map.Q.crop)
#plot(map.Q.crop)
#cellStats(map.Q.crop,"mean")
# RUNOFF - TRMM DATA CORRLETATIONS
plot(coredata(precip.sum.Z.Mo),coredata(qZ.Mo))
plot(coredata(precip.mean.Z.Mo),coredata(qZ.Mo))
plot(coredata(precip.sum.Q.Mo),coredata(qQ.Mo))
plot(coredata(precip.mean.Q.Mo),coredata(qQ.Mo))
plot(coredata(precip.mean.S.Mo),coredata(qS.Mo))
ccf(precip.mean.Z.Mo,qZ.Mo,12);grid() # monthly Zhamashike
ccf(precip.mean.Z.We,qZ.We,52);grid() # weekly Zhamashike
ccf(precip.mean.Z.Da,qZ.Da,365); grid()
ccf(precip.mean.S.Mo,qS.Mo,12);grid() # monthly Zhamashike
ccf(precip.mean.S.We,qS.We,52);grid() # weekly Zhamashike
ccf(precip.mean.S.Da,qS.Da,365); grid()
ccf(precip.mean.Q.Mo,qQ.Mo,12) # monthly Qilian
ccf(precip.mean.Q.We,qQ.We,52);grid() # weekly Qilian
par(mfrow=c(2,2)) # monthly
plot(coredata(precip.mean.S.Mo),coredata(qS.Mo)); grid();abline(0,1)
plot(coredata(lag(precip.mean.S.Mo,1)),coredata(qS.Mo)); grid();abline(0,1)
plot(coredata(lag(precip.mean.S.Mo,2)),coredata(qS.Mo)); grid();abline(0,1)
plot(coredata(lag(precip.mean.S.Mo,3)),coredata(qS.Mo)); grid();abline(0,1)
par(mfrow=c(2,2)) # weekly
plot(coredata(precip.mean.Z.We),coredata(qZ.We)); grid();abline(0,1)
plot(coredata(lag(precip.mean.Z.We,1)),coredata(qZ.We)); grid();abline(0,1)
plot(coredata(lag(precip.mean.Z.We,2)),coredata(qZ.We)); grid();abline(0,1)
plot(coredata(lag(precip.mean.Z.We,3)),coredata(qZ.We)); grid();abline(0,1)
plot(precip.mean.Z.Mo) # monthly
lines(lag(precip.mean.Z.Mo,1),col="red")
lines(qZ.Mo,col="blue")
plot(precip.mean.Z.We) # weekly
lines(lag(precip.mean.Z.We,3),col="red")
lines(qZ.We,col="blue")
# MODELING WITH PRECIPITATION ----
precip.mean.S.Da.rs <-rescale(precip.mean.S.Da,to=c(-1,1))
precip.mean.S.Da.rs.lag <- CasesSeries(precip.mean.S.Da.rs,c(1:maxLag.Da))
precip.mean.S.Da.rs.lag <- na.omit(precip.mean.S.Da.rs.lag)
colDX = ncol(precip.mean.S.Da.rs.lag)
names(precip.mean.S.Da.rs.lag)=paste("Plag",(colDX-1):0,sep="")
precip.mean.S.We.rs <-rescale(precip.mean.S.We,to=c(-1,1))
precip.mean.S.We.rs.lag <- CasesSeries(precip.mean.S.We.rs,c(1:maxLag.We))
precip.mean.S.We.rs.lag <- na.omit(precip.mean.S.We.rs.lag)
colDX = ncol(precip.mean.S.We.rs.lag)
names(precip.mean.S.We.rs.lag)=paste("Plag",(colDX-1):0,sep="")
precip.mean.S.Mo.rs <-rescale(precip.mean.S.Mo,to=c(-1,1))
precip.mean.S.Mo.rs.lag <- CasesSeries(precip.mean.S.Mo.rs,c(1:maxLag.Mo))
precip.mean.S.Mo.rs.lag <- na.omit(precip.mean.S.Mo.rs.lag)
colDX = ncol(precip.mean.S.Mo.rs.lag)
names(precip.mean.S.Mo.rs.lag)=paste("Plag",(colDX-1):0,sep="")
# Models
qP.Model.S.Da <- cbind(precip.mean.S.Da.rs.lag,qS.Da.rs.lag)
qP.Model.S.We <- cbind(precip.mean.S.We.rs.lag,qS.We.rs.lag)
qP.Model.S.Mo <- cbind(precip.mean.S.Mo.rs.lag,qS.Mo.rs.lag)
# mlpe
nRuns=20
qP.S.Da.mlpe <- mining(y~.,data=qP.Model.S.Da,Runs=nRuns,method=c("holdoutorder",2/3,12345),model="mlpe",
search=list(search=mparheuristic("mlpe",n=5),method=c("kfoldorder",2,123),metric="MAE"),
feature="sabs")
qP.S.We.randomForest <- mining(y~.,data=qP.Model.S.We,Runs=nRuns,method=c("holdoutorder",2/3,12345),model="randomForest",
search=list(search=mparheuristic("randomForest",n=5),method=c("kfoldorder",2,123),metric="MAE"))
qP.S.Mo.mlpe <- mining(y~.,data=qP.Model.S.Mo,Runs=nRuns,method=c("holdoutorder",2/3,12345),model="ksvm",
search=list(search=mparheuristic("ksvm",n=5),method=c("kfoldorder",2,123),metric="MAE"),
feature="sabs")
# Monthly
h.Mo <- holdout(qS.Mo.rs.lag$y, ratio = 2/3, mode = "order", seed = 12345) # just for ID later on!
qS.Mo.mlpe.err <- mmetric(qP.S.Mo.mlpe,metric=c("MAE","RMSE"))
ensScatterPlot(qP.S.Mo.mlpe,qP.Model.S.Mo,h.Mo,2,paste("ksvm: Zhamashike + Qilian Monthly, MAE: ",toString(colMeans(qS.Mo.mlpe.err)[[1]])),"observation","forecast")
# Daily
h.Mo <- holdout(qS.Da.rs.lag$y, ratio = 2/3, mode = "order", seed = 12345) # just for ID later on!
qS.Mo.mlpe.err <- mmetric(qP.S.Da.mlpe,metric=c("MAE","RMSE"))
ensScatterPlot(qP.S.Da.mlpe,qP.Model.S.Da,h.Mo,2,paste("mlpe: Zhamashike + Qilian Daily, MAE: ",toString(colMeans(qS.Da.mlpe.err)[[1]])),"observation","forecast")
# Weekly
h.We <- holdout(qS.We.rs.lag$y, ratio = 2/3, mode = "order", seed = 12345) # just for ID later on!
qS.We.randomForest.err <- mmetric(qP.S.We.randomForest,metric=c("MAE","RMSE"))
ensScatterPlot(qP.S.We.randomForest,qP.Model.S.We,h.We,2,paste("rF: Zhamashike + Qilian Weekly, MAE: ",toString(colMeans(qS.We.randomForest.err)[[1]])),"observation","forecast")
# GhcnDaily Station Data
shiny::runApp('Documents/R/statFor')
shiny::runApp('Documents/R/statFor')
shiny::runApp('Documents/R/statFor')
setwd(dir="Documents/R/statFor")
getwd()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
?par
?mar
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
qZ <- read.csv(file="data/stations/Zhamashike_runoff_00_14.csv", header=TRUE, sep=",")
qQ <- read.csv(file="data/stations/Qilian_runoff_00_14.csv",header=TRUE,sep=",")
qY <- read.csv(file="data/stations/Yingluoxia_runoff_00_14.csv",header=TRUE,sep=",")
qZts <- dwmTimeseries(qZ,2000,01,01,sum)
qZDa=qZts[[1]];qZWe=qZts[[2]];qZMo=qZts[[3]];
qQts <- dwmTimeseries(qQ,2000,01,01,sum)
qQDa=qQts[[1]];qQWe=qQts[[2]];qQMo=qQts[[3]];
qYts <- dwmTimeseries(qY,2000,01,01,sum)
qYDa=qYts[[1]];qYWe=qYts[[2]];qYMo=qYts[[3]];
dischargeVarNamePartStation = list('qZ',col="blue")
dischargeVarNamePartTime = list('Da',lty=1)
Da = as.ts(qQDa,qYDa,qZDa)
plot(Da)
plot(Da, range(Da))
range(Da)
Da
?range
range(Da,na.rm = TRUE)
plot(Da, range(Da))
plot(Da, range(Da,na.rm = TRUE))
plot(Da[1])
plot(Da[[1]])
plot(qQDa)
lines(qYDa)
lines(qZDa)
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
shiny::runApp()
